*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="tsgen.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS appconfig AS creadorconfig OF "tsgen.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: cn_cuenta_activo
		*p: cn_cuenta_cliente
		*p: cn_cuenta_egresos
		*p: cn_cuenta_ingreso
		*p: cn_cuenta_producto
		*p: comprobante_remision
		*p: cp_condicion_compra
		*p: cp_moneda_compra
		*p: hc_comision_compra
		*p: hc_flete_compra
		*p: prd_lista_precio
		*p: rh_nropatronal
		*p: rh_sueldo_minimo
		*p: st_codigo_producto
		*p: st_modificaiva
		*p: st_producto_autocodigo
		*p: st_regimenturismo
		*p: sys_moneda_base
		*p: sys_proyecto
		*p: sys_sucursal_base
		*p: tipo_comprobante_compra
		*p: ts_detalle_cheque
		*p: vt_abrir_caja
		*p: vt_busca_en_menu
		*p: vt_cliente_base
		*p: vt_condicion_venta
		*p: vt_cpbt_base
		*p: vt_cpbt_base1
		*p: vt_factura_ventas
		*p: vt_inf_producto
		*p: vt_listaprecio_venta
		*p: vt_moneda_ventas
		*p: vt_ratio
		*p: vt_tpv_generico
	*</DefinedPropArrayMethod>

	cn_cuenta_activo = 1
	cn_cuenta_cliente = 
	cn_cuenta_egresos = 4
	cn_cuenta_ingreso = 5
	cn_cuenta_producto = 
	comprobante_remision = SR
	cp_condicion_compra = .NULL.
	cp_moneda_compra = GS
	hc_comision_compra = 
	hc_flete_compra = .NULL.
	Name = "creadorconfig"
	prd_lista_precio = .NULL.
	rh_nropatronal = 0704-01-0110
	rh_sueldo_minimo = 1230000
	st_codigo_producto = .NULL.
	st_modificaiva = S
	st_producto_autocodigo = F
	st_regimenturismo = S
	sys_moneda_base = GS
	sys_proyecto = S
	sys_sucursal_base = 01
	tipo_comprobante_compra = CO
	ts_detalle_cheque = N
	vt_abrir_caja = N
	vt_busca_en_menu = .NULL.
	vt_cliente_base = .NULL.
	vt_condicion_venta = CONT
	vt_cpbt_base = NV
	vt_cpbt_base1 = .NULL.
	vt_factura_ventas = NV
	vt_inf_producto = S
	vt_listaprecio_venta = .NULL.
	vt_moneda_ventas = GS
	vt_ratio = F
	vt_tpv_generico = F

ENDDEFINE

DEFINE CLASS application AS custom 		&& Clase de aplicación estándar
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" ClassIcon="..\..\futura\bitmaps\default.ico" />

	#INCLUDE "..\include\tastrade.h"
	*<DefinedPropArrayMethod>
		*m: *addinstance		&& Agrega una instancia o incrementa el número de una instancia existente en la matriz aInstance[].
		*m: *antescambiar
		*m: *cleanup		&& Cierra todas las ventanas, restaura el título de la ventana principal, restaura el menú de VFP, etc.
		*m: *cleanup2		&& Postprograma adicional
		*m: *cua_access
		*m: *desencriptar
		*m: *despuescambiar
		*m: *do		&& Muestra el menú principal y ejecuta la aplicación.
		*m: *doejercicio
		*m: *doform		&& Toma un nombre de formulario como parámetro, ejecuta el formulario y muestra una barra de herramientas si es necesario.
		*m: *doformretval		&& Similar a DoForm, excepto que este método está diseñado para funcionar con formularios que devuelven un valor y no se almacena en un SCX.
		*m: *domenu		&& Muestra el menú principal.
		*m: *doreport
		*m: *doreporttext
		*m: *dosys		&& Llama a un sistema
		*m: *encriptar
		*m: *leerconstante		&& Lee las constantes definidas en sys_config.
		*m: *login		&& Muestra un formulario de registro y devuelve el valor devuelto por dicho formulario.
		*m: *permisos		&& Devuelve el permiso para el objeto especificado.
		*m: *releasenavtoolbar		&& Quita la barra de herramientas cuyo nombre está almacenado en la propiedad cToolBar del formulario activo.
		*m: *releasetoolbars		&& Libera todas las barras de herramientas de VFP.
		*m: *removeinstance		&& Quita una instancia o reduce el número de instancias en la matriz aInstance[].
		*m: *setconexion
		*m: *setdatabase
		*m: *shownavtoolbar		&& Crea la barra de herramientas de desplazamiento. Se llama desde el método de evento Load() de cada formulario.
		*m: *showtoolbars		&& Muestra todas las barras de herramientas de VFP que estaban activas cuando se inició la aplicación.
		*p: app
		*p: cdatabase		&& El nombre de la base de datos que se va a utilizar para esta aplicación.
		*p: cmainmenu		&& Nombre del menú principal que se va a ejecutar (archivo .MPR).
		*p: cmainwindcaption		&& El título de la ventana principal para esta aplicación.
		*p: colderror
		*p: coldwindcaption		&& El nombre del título de la ventana principal antes de que se iniciara esta aplicación.
		*p: conexion		&& Indica el nombre de la conexion que utiliza.
		*p: cua		&& Contiene el Codigo de la Unidad Administrativa del usuario registrado actualmente en el sistema.
		*p: cuamanual		&& Indica si el valor oApp.Cua se recupera de la Tabla o se asigna en forma manual.
		*p: data
		*p: grupo		&& Indica el grupo al que pertenece el proyecto.
		*p: hndconn
		*p: lhaderror		&& Ocurrió un error mientras estaba deshabilitado el tratamiento de errores.
		*p: lisclean		&& Indica si el entorno está "limpio".
		*p: lquitting		&& En proceso de cierre
		*p: lseterroroff		&& Deshabilita el tratamiento de errores
		*p: nforminstancecount		&& El número de instancias de formulario abiertas actualmente.
		*p: nromenu
		*p: odbc
		*p: otoolbar		&& Una referencia a la barra de herramientas de desplazamiento.
		*p: periodotrabajo
		*p: servidor		&& Indica el Nombre del Servidor al cual está conectado.
		*p: ubicacion
		*a: ^ainstances[1,4]		&& Contiene nombres de formulario, referencias de objeto, el número de instancias en ejecución actualmente y el número de la siguiente  instancia disponible.
		*a: ^atoolbars[1,1]		&& Matriz de nombres de barras de herramientas de VFP y si estaban abiertas cuando se inició la aplicación.
	*</DefinedPropArrayMethod>

	PROTECTED cmainmenu,coldwindcaption,nforminstancecount,atoolbars,lisclean
	app = 
	cdatabase = datos.dbc		&& El nombre de la base de datos que se va a utilizar para esta aplicación.
	cmainmenu = FARMACIA.MPR		&& Nombre del menú principal que se va a ejecutar (archivo .MPR).
	cmainwindcaption = 		&& El título de la ventana principal para esta aplicación.
	coldwindcaption = 		&& El nombre del título de la ventana principal antes de que se iniciara esta aplicación.
	cua = 		&& Contiene el Codigo de la Unidad Administrativa del usuario registrado actualmente en el sistema.
	data = datos.dbc
	Height = 29
	hndconn = .F.
	Name = "application"
	nforminstancecount = 0		&& El número de instancias de formulario abiertas actualmente.
	nromenu = 500
	odbc = DRIVER=SQL Server;SERVER=ASU5SERV;UID=vgo;APP=Gestion Comercial;DATABASE=sys;LANGUAGE=Español;Trusted_Connection=Yes
	otoolbar = .NULL.		&& Una referencia a la barra de herramientas de desplazamiento.
	periodotrabajo = 13
	Width = 39
	
	PROCEDURE addinstance		&& Agrega una instancia o incrementa el número de una instancia existente en la matriz aInstance[].
		LPARAMETERS TOFORM
		LOCAL LNELEM, LNROW, LCFORMNAME
		LCFORMNAME = TOFORM.NAME
		LNELEM = ASCAN(THIS.AINSTANCES, LCFORMNAME)
		IF LNELEM=0
		IF TYPE("this.aInstances[1,1]")="L"
		LNROW = 1
		ELSE
		LNROW = ALEN(THIS.AINSTANCES, 1)+1
		DIMENSION THIS.AINSTANCES[LNROW, ALEN(THIS.AINSTANCES, 2)]
		ENDIF
		THIS.AINSTANCES[LNROW, 1] = LCFORMNAME
		THIS.AINSTANCES[LNROW, 3] = 0
		THIS.AINSTANCES[LNROW, 4] = 0
		ELSE
		LNROW = ASUBSCRIPT(THIS.AINSTANCES, LNELEM, 1)
		IF TYPE("this.aInstances[lnRow, 2]")<>"O" .OR. ISNULL(THIS.AINSTANCES(LNROW, 2))
		THIS.AINSTANCES[LNROW, 2] = TOFORM
		ENDIF
		TOFORM.LEFT = THIS.AINSTANCES(LNROW,2).LEFT+5
		TOFORM.TOP = THIS.AINSTANCES(LNROW,2).TOP+23
		ENDIF
		THIS.AINSTANCES[LNROW, 3] = THIS.AINSTANCES(LNROW, 3)+1
		THIS.AINSTANCES[LNROW, 4] = THIS.AINSTANCES(LNROW, 4)+1
		RETURN THIS.AINSTANCES(LNROW, 4)
	ENDPROC

	PROCEDURE antescambiar
		LPARAMETERS LCSISTEMA
		
	ENDPROC

	PROCEDURE cleanup		&& Cierra todas las ventanas, restaura el título de la ventana principal, restaura el menú de VFP, etc.
		LOCAL LNFORM, LNFORMTOCLOSE
		LOCAL LOFORM
		THIS.LQUITTING = .T.
		FOR EACH LOFORM IN APPLICATION.FORMS
		IF TYPE("loForm")=="O" .AND. LOFORM.BASECLASS=="Form"
		IF  .NOT. LOFORM.QUERYUNLOAD()
		RETURN .F.
		ENDIF
		LOFORM.RELEASE()
		ENDIF
		ENDFOR
		RETURN .T.
	ENDPROC

	PROCEDURE cleanup2		&& Postprograma adicional
		_SCREEN.CAPTION = THIS.COLDWINDCAPTION
		CLEAR EVENTS
		POP MENU TO MASTER _MSYSMENU
		THIS.SHOWTOOLBARS()
		THIS.LISCLEAN = .T.
	ENDPROC

	PROCEDURE cua_access
		LOCAL CTAG
		IF  .NOT. THIS.CUAMANUAL
		CTAG = THIS.TAG
		THIS.TAG = OAPP.GETEMPLOYEEID()
		IF SQL('Select id_cua from usuarios where employee_id = ?oApp.tag', 'cUsuarioUnidad')>0
		THIS.CUA = CUSUARIOUNIDAD.ID_CUA
		USE IN CUSUARIOUNIDAD
		ENDIF
		THIS.TAG = CTAG
		ENDIF
		RETURN THIS.CUA
	ENDPROC

	PROCEDURE desencriptar
		PARAMETER LCCADENA
		LOCAL LNLONGITUD, I, LCENCRIPTADO, LCCARACTER, J
		LNLONGITUD = LEN(ALLTRIM(LCCADENA))
		LCENCRIPTADO = ''
		J = 1
		SET STEP ON
		FOR I = LNLONGITUD TO 1 STEP -1
		LCCARACTER = ASC(SUBSTR(LCCADENA, I, 1))+(J*2)
		LCENCRIPTADO = LCENCRIPTADO+CHR(LCCARACTER)
		J = J+1
		ENDFOR
		RETURN LCENCRIPTADO
	ENDPROC

	PROCEDURE despuescambiar
		LPARAMETERS LCSISTEMA
	ENDPROC

	PROCEDURE Destroy
		ON ERROR
		RELEASE CONTROLERROR
		IF  .NOT. THIS.LISCLEAN
		THIS.CLEANUP()
		ENDIF
		CLOSE DATABASES ALL
		
		* Destroy ThemesManager object
		If Vartype(_Screen.ThemesManager)=="O"   
		_Screen.RemoveObject("ThemesManager")
		ENDIF
		* Destroy BindWindowsEventsProxy object
		If Type("_vfp.BindWindowsEventsProxy")<>"U"   
		_vfp.BindWindowsEventsProxy = Null
		ENDIF
		* Remove all API libraries from memory
		Set Library To
		
	ENDPROC

	PROCEDURE do		&& Muestra el menú principal y ejecuta la aplicación.
		THIS.DOMENU()
		DO WHILE .T.
			READ EVENTS
			IF THIS.CLEANUP()
				THIS.CLEANUP2
				EXIT
			ENDIF
		ENDDO
		QUIT
	ENDPROC

	PROCEDURE doejercicio
		LPARAMETERS lEjercicio
		= SQL("Select * from ejercicios where IdEmpresa=?oApp.Empresa and Ejercicio=" + lEjercicio, 'cEjercicio')
		oApp.InicioEjercicio = cEjercicio.InicioEjercicio
		oApp.FinalEjercicio = cEjercicio.FinalEjercicio
		_Screen.Caption=STRTRAN(_Screen.Caption,ALLTRIM(STR(oApp.Ejercicio)),lEjercicio)
		oApp.Ejercicio = cEjercicio.Ejercicio
		oApp.Periodo = cEjercicio.Ultimocierre
		
		
		
	ENDPROC

	PROCEDURE doform		&& Toma un nombre de formulario como parámetro, ejecuta el formulario y muestra una barra de herramientas si es necesario.
		LPARAMETERS TCFORM, TCPARM1
		IF PARAMETERS()<2
		DO FORM (TCFORM)
		ELSE
		DO FORM (TCFORM) WITH TCPARM1
		ENDIF
	ENDPROC

	PROCEDURE doformretval		&& Similar a DoForm, excepto que este método está diseñado para funcionar con formularios que devuelven un valor y no se almacena en un SCX.
		LPARAMETERS TCFORM
		LOCAL LOFORM, LURETVAL
		LOFORM = CREATEOBJECT(TCFORM)
		LOFORM.SHOW()
		LURETVAL = LOFORM.URETVAL
		RETURN LURETVAL
	ENDPROC

	PROCEDURE domenu		&& Muestra el menú principal.
		DO (THIS.CMAINMENU)
	ENDPROC

	PROCEDURE doreport
		LPARAMETERS lcReport,lcFormato,lcOpciones,tcAlias,lcArchivoDestino
		LOCAL lcFileStem 
		SET PROCEDURE TO FoxyPreviewerCaller.prg ADDITIVE 
		
		LOCAL loReportViewer as "FoxyPreviewerCaller" OF "FoxyPreviewerCaller.Prg"
		loReportViewer= CREATEOBJECT("FoxyPreviewerCaller")
		
		*SET STEP ON
		
		lcFileStem = lcReport
		*	note - specify full path names to be sure
		lcFrxFileName = SYS(5)+CURDIR() + FORCEEXT( m.lcFileStem,"frx")
		IF TYPE("lcArchivoDestino")="C"
			lcFilename = SYS(5)+CURDIR() + lcArchivoDestino
		ENDIF
		
		
		DO CASE
		CASE lcFormato == "XLS"
			lcFilename =  FORCEEXT( m.lcFilename, "XLS" )
		CASE lcFormato == "DOC"
			lcFilename =  FORCEEXT( m.lcFilename, "DOC" )
		CASE lcFormato == "HTML"
			lcFilename =  FORCEEXT( m.lcFilename, "HTM" )
		CASE lcFormato == "PDF"
			lcFilename =  FORCEEXT( m.lcFilename, "PDF" )
		CASE lcFormato == "TXT"
			lcFilename =  FORCEEXT( m.lcFilename, "TXT" )
		OTHERWISE
			lcFilename =""
		ENDCASE
		
			
		WITH loReportViewer as ReportHelper
		  .cLanguage = "SPANISH"
		  .lExpandFields=.t. 
		  IF TYPE("lcAlias")="C"
			  .AddReport(lcReport, lcOpciones,tcAlias)
		  else
			  .AddReport(lcReport, lcOpciones)
		  ENDIF
		  	  
		  .cDestFile = lcFilename   && Use para crear una salida sin vista previa
		  .RunReport()
		  
		
		  DO CASE
		    CASE .lPrinted	
		      MESSAGEBOX("El informe fue impreso !",64, "Estado del informe")
		    CASE .lSaved
		      MESSAGEBOX("El informe fue guardado en el archivo:" + CHR(13) + .cDestFile,;
		      64, ;
		      "Estado del informe")
		    OTHERWISE
		      *MESSAGEBOX("La vista previa del informe se cerro sin imprimir ni guardar",48, "Estado del informe")
		  ENDCASE
		ENDWITH
		
	ENDPROC

	PROCEDURE doreporttext
		LPARAMETERS lcReport
		*	note - specify full path names to be sure
		lcFrxFileName = SYS(5)+CURDIR() + FORCEEXT( m.lcReport,"txt")
		SET REPORTBEHAVIOR 80
		REPORT FORM (lcReport) TO FILE (lcFrxFileName) ASCII 	
		SET REPORTBEHAVIOR 90
		
		
		
		
	ENDPROC

	PROCEDURE dosys		&& Llama a un sistema
		PARAMETER LCSISTEMA
		LOCAL LCMENU, LCAPP
		*SET COVERAGE TO c:\futura.log ADDITIVE 
		*SET COVERAGE TO futura.log ADDITIVE 
		m.INICIO = SECONDS()
		THIS.ANTESCAMBIAR(LCSISTEMA)
		IF THIS.NROMENU=BAR()
			RETURN
		ENDIF
		
		*!*	*!*			RELEASE POPUPS EXTENDED MOVIMIENTOS, DEFINICIONES
		*!*	*!*			RELEASE PAD _DEFINICIONES OF _MSYSMENU
		*!*	*!*			RELEASE PAD _MOVIMIENTOS OF _MSYSMENU
		*!*	*		SET MARK OF BAR THIS.NROMENU OF "Sistemas" TO  .NOT. MRKBAR('Sistemas', THIS.NROMENU)
		*!*			WAIT windows "Creando Menu"  
		*!*			LCMENU = ALLTRIM(LCSISTEMA)+".mpr" 	
		*!*			DO (LCMENU)
		*!*			WAIT windows "Menu Finalizado"
		*!*	RETURN
		
		***********
		= SQL("select * from sys_Sistemas where idsistema ='"+LCSISTEMA+"'", 'cSistema')
		IF RECCOUNT('cSistema')>0
			IF  .NOT. EMPTY(THIS.SYSMENU)
				RELEASE POPUPS EXTENDED MOVIMIENTOS, DEFINICIONES
				RELEASE PAD _DEFINICIONES OF _MSYSMENU
				RELEASE PAD _MOVIMIENTOS OF _MSYSMENU
				SET MARK OF BAR THIS.NROMENU OF "Sistemas" TO  .NOT. MRKBAR('Sistemas', THIS.NROMENU)
			ENDIF
			THIS.SISTEMA = LCSISTEMA
			THIS.SYSMENU = ALLTRIM(CSISTEMA.MENU)
			THIS.APP = ''
			SET DEFAULT TO (OAPP.UBICACION)
		
			IF  .NOT. EMPTY(CSISTEMA.APP) .AND.  .NOT. ISNULL(CSISTEMA.APP)
				THIS.APP = FULLPATH(RTRIM(CSISTEMA.APP))
			ELSE
				THIS.APP = FULLPATH(RTRIM("futura.EXE"))
		
			ENDIF
			
			LCMENU = ALLTRIM(CSISTEMA.MENU)+".mpr" 	
			DO (LCMENU) IN (this.app)
			
		ELSE
			MESSAGEBOX('No se ha encontrado el menu '+CSISTEMA.MENU, 16, "Futura Software")
			RETURN
		ENDIF
		*LCMENU = ALLTRIM(LCSISTEMA)+".mpr" 	
		*DO (LCMENU)
		
		IF EMPTY(THIS.NOMBREUSUARIO)
			IF SQL([Select ISNULL(RTRIM(ISNULL(first_Name,'')) + ' ' + ISNULL(last_name,''),notes) as Nombre from usuarios where Employee_Id = ']+RTRIM(THIS.CEMPLOYEEID)+['], 'cUsuarios')>0
				THIS.NOMBREUSUARIO = CUSUARIOS.NOMBRE
				USE IN CUSUARIOS
			ENDIF
		ENDIF
		THIS.NROMENU = BAR()
		IF THIS.NROMENU=0
			FOR LNBAR = CNTBAR("Sistemas") TO 1 STEP -1
					IF UPPER(PRMBAR("Sistemas", GETBAR("Sistemas", LNBAR)))=ALLTRIM(UPPER(CSISTEMA.SISTEMA))
					THIS.NROMENU = LNBAR
					EXIT
				ENDIF
			ENDFOR
		ENDIF
		
		IF EMPTY(THIS.APP)
			LCAPP = "futura.EXE"
		ELSE
			LCAPP = THIS.APP
		ENDIF
		
		IF AGETFILEVERSION(LMVERSION, LCAPP)>0
			LCVERSION = ' (v '+LMVERSION(4)+')'
		ELSE
			LCVERSION = ''
		ENDIF
		
		SET MARK OF BAR THIS.NROMENU OF "Sistemas" TO  .NOT. MRKBAR('Sistemas', THIS.NROMENU)
		_SCREEN.CAPTION = ALLTRIM(CSISTEMA.SISTEMA)+LCVERSION+' - '+ALLTRIM(THIS.NOMBREEMPRESA)+' ('+ALLTRIM(STR(THIS.EJERCICIO))+') Usuario: '+ALLTRIM(THIS.NOMBREUSUARIO) + " Suc: " + this.sucursal 
		USE IN CSISTEMA
		*SET COVERAGE TO futura.log ADDITIVE 
		
		= SQL("Exec permiso_usuario '"+THIS.CEMPLOYEEID+"', ?oApp.Sistema", 'lcPermisos')
		
		SELECT LCPERMISOS
		IF RECCOUNT('lcPermisos')>0
			DIMENSION THIS.ARRAYPERMISOS(RECCOUNT('lcPermisos'), 6)
			COPY TO ARRAY THIS.ARRAYPERMISOS
		ENDIF
		USE IN LCPERMISOS
		
		THIS.DESPUESCAMBIAR(LCSISTEMA)
		*SET COVERAGE TO 
	ENDPROC

	PROCEDURE encriptar
		PARAMETER LCCADENA
		LOCAL LNLONGITUD, I, LCENCRIPTADO, LCCARACTER
		LNLONGITUD = LEN(ALLTRIM(LCCADENA))
		LCENCRIPTADO = ''
		FOR I = LNLONGITUD TO 1 STEP -1
		LCCARACTER = ASC(SUBSTR(LCCADENA, I, 1))-(I*2)
		LCENCRIPTADO = LCENCRIPTADO+CHR(LCCARACTER)
		ENDFOR
		RETURN LCENCRIPTADO
	ENDPROC

	PROCEDURE Error
		LPARAMETERS NERROR, CMETHOD, NLINE
		
		lcMENSAJE = "ATENCION : "+MESSAGE()+CHR(13)
		lcMENSAJE = lcMENSAJE+"ERROR: "+ALLTRIM(STR(NERROR))+CHR(13)
		lcMENSAJE = lcMENSAJE+"METODO: "+CMETHOD+CHR(13)
		lcMENSAJE = lcMENSAJE+"LINEA: ("+ALLTRIM(STR(NLINE))+") "+MESSAGE(1)
		
		
		IF _VFP.STARTMODE<>4
			MENSAJE = "ATENCION : "+MESSAGE()+CHR(13)
			MENSAJE = MENSAJE+"ERROR: "+ALLTRIM(STR(NERROR))+CHR(13)
			MENSAJE = MENSAJE+"METODO: "+CMETHOD+CHR(13)
			MENSAJE = MENSAJE+"LINEA: ("+ALLTRIM(STR(NLINE))+") "+MESSAGE(1)
		ELSE
			MENSAJE = "ATENCION: "+MESSAGE()
		ENDIF
		
		=RegistrarError(lcMENSAJE)
		MESSAGEBOX(MENSAJE, 48, "Futura Software")
		
		
		
		RETURN 
		
		
		IF _VFP.STARTMODE<>4
		MENSAJE = "ATENCION : "+MESSAGE()+CHR(13)
		MENSAJE = MENSAJE+"ERROR: "+ALLTRIM(STR(NERROR))+CHR(13)
		MENSAJE = MENSAJE+"METODO: "+CMETHOD+CHR(13)
		MENSAJE = MENSAJE+"LINEA: ("+ALLTRIM(STR(NLINE))+") "+MESSAGE(1)
		ELSE
		MENSAJE = "ATENCION: "+MESSAGE()
		ENDIF
		MESSAGEBOX(MENSAJE)
	ENDPROC

	PROCEDURE Init
		THIS.ADDOBJECT("oEnvironment", "Environment")
		THIS.OENVIRONMENT.SET()
		THIS.UBICACION = SET("default")+CURDIR()
		THIS.COLDWINDCAPTION = _SCREEN.CAPTION
		_SCREEN.CAPTION = THIS.CMAINWINDCAPTION
		CLOSE DATABASES ALL
		IF  .NOT. EMPTY(THIS.CDATABASE)
			THIS.CDATABASE = LEERINI('Ruta', 'System')+THIS.DATA
			OPEN DATABASE (THIS.CDATABASE)
			IF EMPTY(DBC())
				= MESSAGEBOX("El archivo no existe: "+THIS.CDATABASE, 016, "Ha ocurrido un error")
				RETURN .F.
			ENDIF
		ENDIF
		THIS.RELEASETOOLBARS()
		PUSH MENU _MSYSMENU
		THIS.SETCONEXION()
		SET DATABASE TO datos
		LCCSTRING = LEERINI('DEFAULT', 'ODBC')+';UID='+"FuturaApp"+';PWD='+"AppFutura"
		LNHNDCONN = SQLSTRINGCONNECT(LCCSTRING)
		this.hndconn=LNHNDCONN
		
		IF LNHNDCONN<0
			= AERROR(LAERROR)
			LAERROR(2) = 'Error: '+ALLTRIM(STR(LAERROR(5)))+'-'+LAERROR(3)
			= MESSAGEBOX('No tiene permiso para acceder a la BD o el Servidor no existe.'+CHR(13)+LAERROR(2), 48, "Futura Software")
			RETURN .F.
		ENDIF
		*= SQLDISCONNECT(LNHNDCONN)
	ENDPROC

	PROCEDURE leerconstante		&& Lee las constantes definidas en sys_config.
		LPARAMETERS CCONSTANTE, CTIPO
		CVALOR = ''
		IF PCOUNT()=1
			CMDSQL = "Select convert(char(50),dbo.LeerConstante(?oApp.Empresa, '"+CCONSTANTE+"')) as Config "
		ELSE
			CMDSQL = "Select convert("+CTIPO+",dbo.LeerConstante(?oApp.Empresa, '"+CCONSTANTE+"')) as Config "
		ENDIF
		IF SQL(CMDSQL, '_cConfig')>0
			IF RECCOUNT('_cConfig')>0
				CVALOR = _CCONFIG.CONFIG
			ENDIF
			USE IN _CCONFIG
		ENDIF
		RETURN CVALOR
	ENDPROC

	PROCEDURE login		&& Muestra un formulario de registro y devuelve el valor devuelto por dicho formulario.
		RETURN THIS.DOFORMRETVAL("login")
	ENDPROC

	PROCEDURE permisos		&& Devuelve el permiso para el objeto especificado.
		PARAMETER LCIDOBJETO
		LOCAL LNPOSICION
		SET COVERAGE TO futura.log ADDITIVE 
		LNPOSICION = ASCAN(THIS.ARRAYPERMISOS, LCIDOBJETO)
		
		IF LNPOSICION>0
			RETURN THIS.ARRAYPERMISOS(LNPOSICION+1)
		ELSE
			RETURN .F.
		ENDIF
		
		SET COVERAGE TO 
		
	ENDPROC

	PROCEDURE releasenavtoolbar		&& Quita la barra de herramientas cuyo nombre está almacenado en la propiedad cToolBar del formulario activo.
		THIS.NFORMINSTANCECOUNT = THIS.NFORMINSTANCECOUNT-1
		IF THIS.NFORMINSTANCECOUNT=0
			THIS.OTOOLBAR = .NULL.
			RELEASE POPUPS EXTENDED NAVIGATION
			RELEASE PAD _EXPLORACION OF _MSYSMENU
		ENDIF
		
	ENDPROC

	PROTECTED PROCEDURE releasetoolbars		&& Libera todas las barras de herramientas de VFP.
		LOCAL I
		DIMENSION THIS.ATOOLBARS[12, 2]
		THIS.ATOOLBARS[1, 1] = "Diseñador de formularios"
		THIS.ATOOLBARS[2, 1] = "Standard"
		THIS.ATOOLBARS[3, 1] = "Distribución"
		THIS.ATOOLBARS[4, 1] = "Diseñador de consultas"
		THIS.ATOOLBARS[5, 1] = "Diseñador de vistas"
		THIS.ATOOLBARS[6, 1] = "Paleta de colores"
		THIS.ATOOLBARS[7, 1] = "Controles de formularios"
		THIS.ATOOLBARS[8, 1] = "Diseñador de bases de datos"
		THIS.ATOOLBARS[9, 1] = "Diseñador de informes"
		THIS.ATOOLBARS[10, 1] = "Controles de informes"
		THIS.ATOOLBARS[11, 1] = "Vista preliminar"
		THIS.ATOOLBARS[12, 1] = "Comandos"
		FOR I = 1 TO ALEN(THIS.ATOOLBARS, 1)
		THIS.ATOOLBARS[I, 2] = WVISIBLE(THIS.ATOOLBARS(I, 1))
		IF THIS.ATOOLBARS(I, 2)
		HIDE WINDOW (THIS.ATOOLBARS(I, 1))
		ENDIF
		ENDFOR
	ENDPROC

	PROCEDURE removeinstance		&& Quita una instancia o reduce el número de instancias en la matriz aInstance[].
		LPARAMETERS TCFORMNAME
		LOCAL LNELEM, LNROW
		LNELEM = ASCAN(THIS.AINSTANCES, TCFORMNAME)
		IF LNELEM>0
		LNROW = ASUBSCRIPT(THIS.AINSTANCES, LNELEM, 1)
		IF THIS.AINSTANCES(LNROW, 3)=1
		IF ALEN(THIS.AINSTANCES, 1)>1
		= ADEL(THIS.AINSTANCES, LNROW)
		DIMENSION THIS.AINSTANCES[ALEN(THIS.AINSTANCES, 1)-1, ALEN(THIS.AINSTANCES, 2)]
		ELSE
		THIS.AINSTANCES = .F.
		ENDIF
		ELSE
		THIS.AINSTANCES[LNROW, 3] = THIS.AINSTANCES(LNROW, 3)-1
		ENDIF
		ENDIF
	ENDPROC

	PROCEDURE setconexion
		LOCAL LNCONEXIONES AS INTEGER, LCODBCDEFAULT AS STRING, LCODBC AS STRING, LCSEGURIDAD, LNINIPOS, LNFINPOS, LCCADENA, LCNEWCADENA
		LCSEGURIDAD = LEERINI('Seguridad', 'SYSTEM')
		LNCONEXIONES = ADBOBJECTS(LACONEXION, "CONNECTION")
		LCODBCDEFAULT = LEERINI('DEFAULT', 'ODBC')
		IF EMPTY(LCODBCDEFAULT)
			LCODBCDEFAULT = THIS.ODBC
			= ESCRIBIRINI(LCODBCDEFAULT, 'DEFAULT', 'ODBC')
		ELSE
			THIS.ODBC=LCODBCDEFAULT 
		ENDIF
		
		FOR I = 1 TO LNCONEXIONES
			LCODBC = LEERINI(LACONEXION(I), 'ODBC')
			IF EMPTY(LCODBC)
				LCODBC = LCODBCDEFAULT
			ENDIF
			IF ALLTRIM(DBGETPROP(LACONEXION(I), "CONNECTION", "CONNECTSTRING"))<>ALLTRIM(LCODBC) 
				IF LCSEGURIDAD='App'
					LCNEWCADENA = ';UID='+"FuturaApp"
					LNINIPOS = AT(';UID=', UPPER(LCODBC))
					IF LNINIPOS=0
						LCODBC = LCODBC+LCNEWCADENA
					ELSE
						LNFINPOS = AT(';', UPPER(SUBSTR(LCODBC, LNINIPOS+1)))
						IF LNFINPOS=0
							LNFINPOS = LEN(ALLTRIM(LCODBC))
						ENDIF
						LCCADENA = SUBSTR(LCODBC, LNINIPOS, LNFINPOS)
						LCODBC = STRTRAN(LCODBC, LCCADENA, LCNEWCADENA)
					ENDIF
					LCNEWCADENA = ';PWD='+"AppFutura"
					LNINIPOS = AT(';PWD=', UPPER(LCODBC))
					IF LNINIPOS=0
						LCODBC = LCODBC+LCNEWCADENA
					ELSE
						LNFINPOS = AT(';', UPPER(SUBSTR(LCODBC, LNINIPOS+1)))
						IF LNFINPOS=0
							LNFINPOS = LEN(ALLTRIM(LCODBC))
						ENDIF
						LCCADENA = SUBSTR(LCODBC, LNINIPOS, LNFINPOS)
						LCODBC = STRTRAN(LCODBC, LCCADENA, LCNEWCADENA)
					ENDIF
					LCNEWCADENA = ';Trusted_Connection=No'
					LNINIPOS = AT(';TRUSTED_CONNECTION=', UPPER(LCODBC))
					
					IF LNINIPOS=0
						LCODBC = LCODBC+LCNEWCADENA
					ELSE
						LNFINPOS = AT(';', UPPER(SUBSTR(LCODBC, LNINIPOS+1)))
						IF LNFINPOS=0
							LNFINPOS = LEN(ALLTRIM(LCODBC))
						ENDIF
						LCCADENA = SUBSTR(LCODBC, LNINIPOS, LNFINPOS)
						LCODBC = STRTRAN(LCODBC, LCCADENA, LCNEWCADENA)
					ENDIF
				ENDIF
				
				= DBSETPROP(LACONEXION(I), "CONNECTION", "CONNECTSTRING", LCODBC)
			ENDIF
		ENDFOR
		CLOSE DATABASES
		OPEN DATABASE (THIS.CDATABASE)
	ENDPROC

	PROCEDURE setdatabase
		LPARAMETERS LODE
		LOCAL LADATA(1, 2)
		IF ADATABASES(LADATA)=0 .OR. ASCAN(LADATA, UPPER(OAPP.CDATABASE))=0
		OPEN DATABASE (OAPP.CDATABASE)
		ENDIF
		SET DATABASE TO (OAPP.CDATABASE)
		IF PCOUNT()=0
		RETURN
		ENDIF
		FOR I = 1 TO 50
		IF TYPE('loDE.objects(i)')='O'
		LODE.OBJECTS(I).DATABASE = OAPP.CDATABASE
		ELSE
		EXIT
		ENDIF
		ENDFOR
	ENDPROC

	PROCEDURE shownavtoolbar		&& Crea la barra de herramientas de desplazamiento. Se llama desde el método de evento Load() de cada formulario.
		LPARAMETERS TCTOOLBAR
		IF THIS.NFORMINSTANCECOUNT=0
		SET SYSMENU ON
		THIS.OTOOLBAR = CREATEOBJECT(TCTOOLBAR)
		THIS.OTOOLBAR.SHOW()
		THIS.OTOOLBAR.REFRESH()
		DO navigate.mpr
		ENDIF
		THIS.NFORMINSTANCECOUNT = THIS.NFORMINSTANCECOUNT+1
	ENDPROC

	PROTECTED PROCEDURE showtoolbars		&& Muestra todas las barras de herramientas de VFP que estaban activas cuando se inició la aplicación.
		LOCAL I
		FOR I = 1 TO ALEN(THIS.ATOOLBARS, 1)
		IF THIS.ATOOLBARS(I, 2)
		SHOW WINDOW (THIS.ATOOLBARS(I, 1))
		ENDIF
		ENDFOR
	ENDPROC

ENDDEFINE

DEFINE CLASS creadorconfig AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: *actualizar
	*</DefinedPropArrayMethod>

	Name = "creadorconfig"
	
	PROCEDURE actualizar
		THIS.SAVEASCLASS(THIS.CLASSLIBRARY, "AppConfig")
		
	ENDPROC

	PROCEDURE Init
		LOCAL LCALIAS
		LCALIAS = ALIAS()
		IF SQL("Select Constante, convert(char(50),valor) as Valor from sys_config where idEmpresa = ?oApp.Empresa", '_cConfig')>0
		IF RECCOUNT('_cConfig')>0
		SELECT _CCONFIG
		SCAN
		THIS.ADDPROPERTY(ALLTRIM(_CCONFIG.CONSTANTE), ALLTRIM(_CCONFIG.VALOR))
		ENDSCAN
		USE IN _CCONFIG
		ENDIF
		ENDIF
		IF  .NOT. EMPTY(LCALIAS)
		SELECT (LCALIAS)
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS environment AS custom 		&& Clase de información de entorno
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "..\include\tastrade.h"
	*<DefinedPropArrayMethod>
		*m: *reset		&& Restablece los comandos SET a su valor original
		*m: *set		&& Establece todos los comandos SET.
		*p: coldbell		&& Valor de SET('BELL')
		*p: coldclasslib		&& Valor de gcClassLib
		*p: coldcompatible
		*p: coldconfirm		&& Valor de SET('CONFIRM')
		*p: colddeleted		&& Valor de SET('DELETED')
		*p: colddir		&& Valor de gcOldDir
		*p: coldescape		&& Valor de gcOldEscape
		*p: coldexact		&& Valor de SET('EXACT')
		*p: coldexclusive		&& Valor de SET('EXCLUSIVE')
		*p: coldhelp		&& Valor de SET('HELP')
		*p: coldintensity		&& Valor de SET('INTENSITY')
		*p: coldmultilocks		&& Valor de SET('MULTILOCKS')
		*p: coldnear		&& Valor de SET('NEAR')
		*p: coldnotify		&& Valor de SET('NOTIFY')
		*p: coldonshutdown		&& Valor de ON('SHUTDOWN')
		*p: coldpath		&& Valor de gcOldPath
		*p: coldproc		&& Valor de SET('PROCEDURE')
		*p: coldsafety		&& Valor de SET('SAFETY')
		*p: coldstatus		&& Valor de SET('STATUS BAR')
		*p: coldtalk		&& Valor de gcOldTalk
		*p: noldmemo		&& Valor de SET('MEMOWIDTH')
	*</DefinedPropArrayMethod>

	PROTECTED coldbell,coldclasslib,coldconfirm,colddeleted,colddir,coldescape,coldexact,coldexclusive,coldhelp,coldintensity,coldmultilocks,coldnear,coldnotify,coldonshutdown,coldpath,coldproc,coldsafety,coldstatus,coldtalk,noldmemo
	coldbell = 		&& Valor de SET('BELL')
	coldclasslib = 		&& Valor de gcClassLib
	coldconfirm = 		&& Valor de SET('CONFIRM')
	colddeleted = 		&& Valor de SET('DELETED')
	colddir = 		&& Valor de gcOldDir
	coldescape = 		&& Valor de gcOldEscape
	coldexact = 		&& Valor de SET('EXACT')
	coldexclusive = 		&& Valor de SET('EXCLUSIVE')
	coldhelp = 		&& Valor de SET('HELP')
	coldintensity = 		&& Valor de SET('INTENSITY')
	coldmultilocks = 		&& Valor de SET('MULTILOCKS')
	coldnear = 		&& Valor de SET('NEAR')
	coldnotify = 		&& Valor de SET('NOTIFY')
	coldonshutdown = 		&& Valor de ON('SHUTDOWN')
	coldpath = 		&& Valor de gcOldPath
	coldproc = 		&& Valor de SET('PROCEDURE')
	coldsafety = 		&& Valor de SET('SAFETY')
	coldstatus = 		&& Valor de SET('STATUS BAR')
	coldtalk = 		&& Valor de gcOldTalk
	Height = 17
	Name = "environment"
	noldmemo = 0		&& Valor de SET('MEMOWIDTH')
	Width = 100
	
	PROCEDURE Destroy
		THIS.RESET()
	ENDPROC

	PROCEDURE Init
		THIS.COLDTALK = GCOLDTALK
		THIS.COLDPATH = GCOLDPATH
		THIS.COLDDIR = GCOLDDIR
		THIS.COLDCLASSLIB = GCOLDCLASSLIB
		THIS.COLDESCAPE = GCOLDESCAPE
		THIS.COLDSAFETY = SET('SAFETY')
		THIS.COLDPROC = SET('PROCEDURE')
		THIS.COLDSTATUS = SET('STATUS BAR')
		THIS.NOLDMEMO = SET('MEMOWIDTH')
		THIS.COLDMULTILOCKS = SET('MULTILOCKS')
		THIS.COLDHELP = SET('HELP', 1)
		THIS.COLDDELETED = SET('DELETED')
		THIS.COLDEXCLUSIVE = SET('EXCLUSIVE')
		THIS.COLDNOTIFY = SET('NOTIFY')
		THIS.COLDBELL = SET('BELL')
		THIS.COLDNEAR = SET('NEAR')
		THIS.COLDEXACT = SET('EXACT')
		THIS.COLDINTENSITY = SET('INTENSITY')
		THIS.COLDCONFIRM = SET('CONFIRM')
		THIS.COLDONSHUTDOWN = ON('SHUTDOWN')
		THIS.COLDCOMPATIBLE = SET("COMPATIBLE")
	ENDPROC

	PROCEDURE reset		&& Restablece los comandos SET a su valor original
		LOCAL LUTEMP
		SET PATH TO (THIS.COLDPATH)
		LUTEMP = THIS.COLDCLASSLIB
		SET CLASSLIB TO  &LUTEMP
		LUTEMP = THIS.COLDPROC
		SET PROCEDURE TO &LUTEMP
		SET MEMOWIDTH TO THIS.NOLDMEMO
		LUTEMP = THIS.COLDMULTILOCKS
		SET MULTILOCKS &LUTEMP
		LUTEMP = THIS.COLDSAFETY
		SET SAFETY &LUTEMP
		LUTEMP = THIS.COLDSTATUS
		SET STATUS BAR &LUTEMP
		CD (THIS.COLDDIR)
		LUTEMP = THIS.COLDDELETED
		SET DELETED &LUTEMP
		LUTEMP = THIS.COLDEXCLUSIVE
		SET EXCLUSIVE &LUTEMP
		IF FILE(THIS.COLDHELP)
		SET HELP TO (THIS.COLDHELP)
		ENDIF
		LUTEMP = THIS.COLDNOTIFY
		SET NOTIFY &LUTEMP
		LUTEMP = THIS.COLDBELL
		SET BELL &LUTEMP
		LUTEMP = THIS.COLDNEAR
		SET NEAR &LUTEMP
		LUTEMP = THIS.COLDEXACT
		SET EXACT &LUTEMP
		LUTEMP = THIS.COLDINTENSITY
		SET INTENSITY &LUTEMP
		LUTEMP = THIS.COLDCONFIRM
		SET CONFIRM &LUTEMP
		LUTEMP = THIS.COLDONSHUTDOWN
		ON SHUTDOWN &LUTEMP
		LUTEMP = THIS.COLDESCAPE
		SET ESCAPE &LUTEMP
		LUTEMP = THIS.COLDCOMPATIBLE
		SET COMPATIBLE &LUTEMP
		LUTEMP = THIS.COLDTALK
		SET TALK &LUTEMP
		SET HELP ON
	ENDPROC

	PROCEDURE set		&& Establece todos los comandos SET.
		SET SAFETY OFF
		SET PROCEDURE TO UTILITY.PRG
		SET CLASSLIB TO MAIN, TSBASE, TSGEN, LOGIN, FUTURA, TPV
		SET MEMOWIDTH TO 120
		SET MULTILOCKS ON
		SET DELETED ON
		SET EXCLUSIVE OFF
		SET NOTIFY OFF
		SET BELL OFF
		SET NEAR OFF
		SET EXACT OFF
		SET INTENSITY OFF
		SET CONFIRM ON
		SET COMPATIBLE FOXPLUS
		SET SYSFORMATS ON
		SET DATE SHORT
		IF FILE("ayuda.chm")
		SET HELP TO ayuda.chm
		ENDIF
		IF  .NOT. .F.
		SET ESCAPE OFF
		ELSE
		SET ESCAPE ON
		ENDIF
		ON SHUTDOWN DO ONSHUTDOWN
		
	ENDPROC

ENDDEFINE

DEFINE CLASS splitter AS control 		&& Control básico de división horizontal. Se usa en el formulario Información técnica. 
 	*< CLASSDATA: Baseclass="control" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpHandle" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\tastrade.h"
	*<DefinedPropArrayMethod>
		*m: *getleftedge		&& Devuelve el valor de la propiedad nLeftEdge.
		*m: *getrightedge		&& Devuelve el valor de la propiedad nRightEdge.
		*m: *updatecontrols		&& Se llama cuando el control ha cambiado.
		*p: nleftedge		&& El borde izquierdo del control.
		*p: nrightedge		&& El borde derecho del control.
	*</DefinedPropArrayMethod>

	PROTECTED nleftedge,nrightedge
	BackColor = 128,128,128
	Height = 247
	Name = "splitter"
	nleftedge = 0		&& El borde izquierdo del control.
	nrightedge = 0		&& El borde derecho del control.
	SpecialEffect = 2
	Width = 6

	ADD OBJECT 'shpHandle' AS shape WITH ;
		BackColor = 0,0,0, ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		BorderWidth = 0, ;
		ClassLibrary = "c:\fox30\nwind\beta1\mainsamp\libs\nwbasobj.vcx", ;
		FillColor = 192,192,192, ;
		FillStyle = 0, ;
		Height = 247, ;
		Left = 0, ;
		MousePointer = 9, ;
		Name = "shpHandle", ;
		SpecialEffect = 0, ;
		Top = 0, ;
		Width = 6
		*< END OBJECT: BaseClass="shape" />
	
	PROCEDURE getleftedge		&& Devuelve el valor de la propiedad nLeftEdge.
		RETURN THIS.NLEFTEDGE
		
	ENDPROC

	PROCEDURE getrightedge		&& Devuelve el valor de la propiedad nRightEdge.
		RETURN THIS.NRIGHTEDGE
	ENDPROC

	PROCEDURE Init
		IF TYPE("m.gTTrade")<>'L' .OR.  .NOT. M.GTTRADE
		= MESSAGEBOX("Esta clase no se puede utilizar fuera de la aplicación Tastrade.")
		RETURN .F.
		ENDIF
	ENDPROC

	PROCEDURE updatecontrols		&& Se llama cuando el control ha cambiado.
		LOCAL LNOBJCTR
		THIS.NLEFTEDGE = THIS.LEFT
		THIS.NRIGHTEDGE = THIS.LEFT+THIS.WIDTH
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .T.
		THISFORM.LSETERROROFF = .T.
		FOR LNOBJCTR = 1 TO ALEN(THIS.PARENT.AOBJSPLITMOVE)
		THIS.PARENT.AOBJSPLITMOVE(LNOBJCTR).MOVE()
		ENDFOR
		THISFORM.LSETERROROFF = .F.
		THISFORM.LHADERROR = .F.
		_SCREEN.ACTIVEFORM.LOCKSCREEN = .F.
		_SCREEN.ACTIVEFORM.REFRESH()
	ENDPROC

	PROCEDURE shpHandle.MouseDown
		PARAMETER NBUTTON, NSHIFT, NXCOORD, NYCOORD
		LOCAL LNOLDPOS, LNAVGCHARWIDTH, LNMINPOS, LNMAXPOS, LNCURPOS, LNPARENTLEFT
		LNOLDPOS = THIS.PARENT.LEFT
		LNAVGCHARWIDTH = FONTMETRIC(6)
		LNPARENTLEFT = THIS.PARENT.LEFT
		LNMINPOS = 111
		LNMAXPOS = LNMINPOS+303
		DO WHILE MDOWN()
		LNCURPOS = MCOL()*LNAVGCHARWIDTH
		THIS.PARENT.MOVE(MAX(LNMINPOS, MIN(LNCURPOS, LNMAXPOS)))
		ENDDO
		IF THIS.LEFT<>LNOLDPOS
		THIS.PARENT.UPDATECONTROLS()
		ENDIF
	ENDPROC

ENDDEFINE
